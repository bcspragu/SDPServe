<!DOCTYPE html>
<html lang="en">
<head>
<title>BeatBeam</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
<script src="//cdnjs.cloudflare.com/ajax/libs/raphael/2.1.2/raphael-min.js"></script>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script type="text/javascript">
// RaphaelJS objects
var canvas;
var paper;

// WebSocket object
var conn;

// Parameters from server
var XCOUNT = {{ .XCount }};
var YCOUNT = {{ .YCount }};

// Local map
var blocks = new Array(XCOUNT);
for (var i = 0; i < XCOUNT; i++) {
  blocks[i] = new Array(YCOUNT);
}

var start_grid = JSON.parse("{{ .Grid }}");

$(function(){
  // Set the canvas
  canvas = $("#canvas");
  paper = Raphael(canvas.get(0), "100%", "100%");

  // Establish a WebSocket connection
  if (window["WebSocket"]) {
      conn = new WebSocket("ws://bsprague.com/sdp/ws");
      conn.onerror = function(evt) {
        console.log(evt);
      }
      conn.onclose = function(evt) {
        console.log(evt);
      }
      conn.onmessage = function(evt) { // Message received. evt.data is something
        var data = JSON.parse(evt.data);
        var x = data.x;
        var y = data.y;

        setBlock(data.x, data.y, data.on);
      }
  } else {
      // Your browser does not support WebSockets
  }

  // conn.send(msg.val());
  drawCanvas();
  initState();
  $(window).resize(drawCanvas);
});

function drawCanvas() {
  // Subtract the spacing so we don't butt up against the right/bottom edge
  var width = canvas.width();
  var height = canvas.height();

  var size;
  var spacing
  var extra_x = 0;
  var extra_y = 0;
  if (width < height) {
    spacing = Math.ceil(width / XCOUNT / 10);
    size = Math.floor((width - spacing) / XCOUNT);
    extra_y = Math.floor((height - YCOUNT * size - spacing) / YCOUNT);
  } else {
    spacing = Math.ceil(height / YCOUNT / 10);
    size = Math.floor((height - spacing) / YCOUNT);
    extra_x = Math.floor((width - XCOUNT * size - spacing) / XCOUNT);
  }

  for (var i = 0; i < XCOUNT; i++) {
    for (var j = 0; j < YCOUNT; j++) {
      if (typeof blocks[i][j] === "undefined") {
        blocks[i][j] = paper.rect(i * (size + extra_x) + spacing,
                                  j * (size + extra_y) + spacing,
                                  size + extra_x - spacing,
                                  size + extra_y - spacing)
                                  .attr({fill: "white"})
                                  .data('x', i)
                                  .data('y', j)
                                  .data('on', false)
                                  .click(function() {
                                    if (typeof conn !== "undefined") {
                                      var x = this.data('x');
                                      var y = this.data('y');
                                      // Toggle on
                                      var on = !this.data('on');
                                      setBlock(x,y,on)
                                      conn.send(JSON.stringify({x: x, y: y, on: on}));
                                    }
                                  })
                                  .touchstart(function(e) {
                                    e.preventDefault();
                                    if (typeof conn !== "undefined") {
                                      var x = this.data('x');
                                      var y = this.data('y');
                                      // Toggle on
                                      var on = !this.data('on');
                                      setBlock(x,y,on)
                                      conn.send(JSON.stringify({x: x, y: y, on: on}));
                                    }
                                  });
        } else {
          var block = blocks[i][j];
          block.attr({x: i * (size + extra_x) + spacing,
                      y: j * (size + extra_y) + spacing,
                      width: size + extra_x - spacing,
                      height: size+ extra_y - spacing});
        }
    }
  }
}

function setBlock(x, y, state) {
  var block = blocks[x][y];
  if (state) {
    block.attr({fill: 'red'});
  } else {
    block.attr({fill: 'white'});
  }
  block.data('on', state);
}

function initState() {
  for (var i = 0; i < XCOUNT; i++) {
    for (var j = 0; j < XCOUNT; j++) {
      setBlock(i, j, start_grid[i][j]);
    }
  }
}
</script>
<style type="text/css">
html, body, #canvas {
    overflow: hidden;
    padding: 0;
    margin: 0;
    width: 100%;
    height: 100%;
    background: black;
}
</style>
</head>
<body>
  <div id="canvas"></div>
</body>
</html>
